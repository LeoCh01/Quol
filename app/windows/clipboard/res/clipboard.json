{
  "copy": [
    "import heapq\nfrom collections import deque\n\nimport psutil\nfrom GPUtil import GPUtil\nimport pyqtgraph as pg\nfrom PySide6.QtCore import QTimer, QThread, Signal, QObject, Qt\nfrom PySide6.QtWidgets import QLabel, QTableWidget, QHeaderView, QTableWidgetItem\n\nfrom lib.quol_window import QuolMainWindow\nfrom lib.window_loader import WindowInfo, WindowContext\n\n\nclass MainWindow(QuolMainWindow):\n    def __init__(self, window_info: WindowInfo, window_context: WindowContext):\n        super().__init__('Stats', window_info, window_context, default_geometry=(10, 130, 180, 1), show_config=False)\n\n        self.max_points = 30\n        self.cpu_data = deque([0.0] * self.max_points, maxlen=self.max_points)\n        self.ram_data = deque([0.0] * self.max_points, maxlen=self.max_points)\n        self.gpu_data = deque([0.0] * self.max_points, maxlen=self.max_points)\n        self.gpu_percent = 0\n        self.top_procs = []\n\n        self.cpu_plot, self.cpu_curve = self.create_plot(\"CPU (%)\", 'cyan')\n        self.ram_plot, self.ram_curve = self.create_plot(\"RAM (%)\", 'orange')\n        self.gpu_plot, self.gpu_curve = self.create_plot(\"GPU (%)\", 'green')\n        self.plots = [self.cpu_plot, self.ram_plot, self.gpu_plot]\n        self.metrics = [\"CPU\", \"RAM\", \"GPU\"]\n        self.current_plot_index = 0\n\n        self.layout.addWidget(self.plots[self.current_plot_index])\n        self.plots[self.current_plot_index].scene().sigMouseClicked.connect(self.cycle_plot)\n\n        self.process_table = QTableWidget(3, 2)\n        header = self.process_table.horizontalHeader()\n        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)\n        header.setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)\n        header.setVisible(False)\n        self.process_table.verticalHeader().setVisible(False)\n        self.process_table.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)\n        self.process_table.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)\n        self.process_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)\n        self.process_table.setFocusPolicy(Qt.FocusPolicy.NoFocus)\n        self.process_table.setSelectionMode(QTableWidget.SelectionMode.NoSelection)\n        self.layout.addWidget(self.process_table)\n\n        self.net_label = QLabel(\"\u2191 0.0 KB/s \u2193 0.0 KB/s\")\n        self.layout.addWidget(self.net_label)\n        self.last_net_io = psutil.net_io_counters()\n\n        # Timers\n        self.timer = QTimer(self)\n        self.timer.timeout.connect(self.update_main_stats)\n        self.timer.start(1000)\n\n        # Background thread\n        self.worker = BackgroundWorker()\n        self.worker_thread = QThread()\n        self.worker.moveToThread(self.worker_thread)\n        self.worker.updated.connect(self.update_background_stats)\n        self.worker_thread.started.connect(self.worker.run)\n        self.worker_thread.start()\n\n    def create_plot(self, title, color):\n        plot_widget = pg.PlotWidget()\n        plot_widget.setMinimumHeight(90)\n\n        plot_widget.setBackground('#1e1e1e')\n        plot_widget.showGrid(x=True, y=True)\n        plot_widget.getAxis('bottom').setTicks([])\n        plot_widget.plotItem.enableAutoRange(axis=pg.ViewBox.XYAxes, enable=True)\n\n        curve = plot_widget.plot(pen=pg.mkPen(color=color, width=2))\n        plot_widget.setTitle(f\"{title} (0%)\")\n        return plot_widget, curve\n\n    def cycle_plot(self, event):\n        current_plot = self.plots[self.current_plot_index]\n        self.layout.removeWidget(current_plot)\n        current_plot.scene().sigMouseClicked.disconnect(self.cycle_plot)\n        current_plot.hide()\n\n        self.current_plot_index = (self.current_plot_index + 1) % len(self.plots)\n        next_plot = self.plots[self.current_plot_index]\n\n        self.layout.insertWidget(0, next_plot)\n        next_plot.show()\n        next_plot.scene().sigMouseClicked.connect(self.cycle_plot)\n\n        metric = self.metrics[self.current_plot_index]\n        self.process_table.setHorizontalHeaderLabels([\"Process\", metric])\n        self.update_process_table()\n\n    def update_main_stats(self):\n        cpu_percent = psutil.cpu_percent()\n        self.cpu_data.append(cpu_percent)\n        self.cpu_curve.setData(list(self.cpu_data))\n        self.cpu_plot.setTitle(f\"CPU ({cpu_percent:.1f}%)\")\n\n        ram = psutil.virtual_memory()\n        self.ram_data.append(ram.percent)\n        self.ram_curve.setData(list(self.ram_data))\n        self.ram_plot.setTitle(f\"RAM ({ram.percent:.1f}%)\")\n\n        self.gpu_data.append(self.gpu_percent)\n        self.gpu_curve.setData(list(self.gpu_data))\n        self.gpu_plot.setTitle(f\"GPU ({self.gpu_percent:.1f}%)\")\n\n        net_io = psutil.net_io_counters()\n        sent_speed = (net_io.bytes_sent - self.last_net_io.bytes_sent) / 1024\n        recv_speed = (net_io.bytes_recv - self.last_net_io.bytes_recv) / 1024\n        self.net_label.setText(f\"\u2191 {sent_speed:.1f} KB/s   \u2193 {recv_speed:.1f} KB/s\")\n        self.last_net_io = net_io\n\n        self.update_process_table()\n\n    def update_process_table(self):\n        metric_index = self.current_plot_index\n        metric_keys = ['cpu_percent', 'memory_percent', 'gpu_percent']\n        metric_key = metric_keys[metric_index]\n\n        top3 = heapq.nlargest(3, self.top_procs, key=lambda p: p.get(metric_key, 0.0))\n\n        self.process_table.setRowCount(len(top3))\n\n        for row, proc in enumerate(top3):\n            name_item = QTableWidgetItem(proc['name'][:20])\n            value = proc.get(metric_key, 0.0)\n            value_item = QTableWidgetItem(f\"{value:.1f}%\")\n            for col, item in enumerate([name_item, value_item]):\n                item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)\n                self.process_table.setItem(row, col, item)\n\n        self.process_table.setFixedHeight(75)\n        self.process_table.setRowHeight(0, 5)\n        self.process_table.setRowHeight(1, 5)\n\n    def update_background_stats(self, top_procs, gpu_percent):\n        self.gpu_percent = gpu_percent\n        for p in top_procs:\n            p['gpu_percent'] = gpu_percent\n        self.top_procs = top_procs\n\n    def closeEvent(self, event):\n        self.worker.running = False\n        self.worker_thread.quit()\n        self.worker_thread.wait()\n        super().closeEvent(event)\n\n\nclass BackgroundWorker(QObject):\n    updated = Signal(list, float)\n\n    def __init__(self):\n        super().__init__()\n        self.running = True\n\n    def run(self):\n        while self.running:\n            try:\n                procs = []\n                for p in psutil.process_iter(['name', 'cpu_percent', 'memory_percent']):\n                    info = p.info\n                    if info['cpu_percent'] is None or (info['cpu_percent'] < 1.0 and info['memory_percent'] < 1.0):\n                        continue\n                    elif info['name'] == 'System Idle Process':\n                        continue\n                    procs.append({\n                        'name': info.get('name', 'Unknown'),\n                        'cpu_percent': info.get('cpu_percent', 0.0),\n                        'memory_percent': info.get('memory_percent', 0.0)\n                    })\n            except Exception:\n                procs = []\n\n            try:\n                gpus = GPUtil.getGPUs()\n                gpu_percent = gpus[0].load * 100 if gpus else 0.0\n            except Exception:\n                gpu_percent = 0.0\n\n            for proc in procs:\n                proc['gpu_percent'] = gpu_percent\n\n            self.updated.emit(procs, gpu_percent)\n\n            for _ in range(30):\n                if not self.running:\n                    return\n                QThread.msleep(100)\n",
    "CLD6ZWU35GTH",
    "def update_background_stats(self, top_procs, gpu_percent):\n        self.gpu_percent = gpu_percent\n\n        # Filter out processes with unnecessary fields like `MemCompression`\n        for p in top_procs:\n            p['gpu_percent'] = gpu_percent\n            # Remove unwanted fields\n            p = {key: value for key, value in p.items() if key in ['name', 'cpu_percent', 'memory_percent', 'gpu_percent']}\n\n        self.top_procs = top_procs",
    "Timer connected\nrun() called\nTimer started",
    "cpu_percent = psutil.cpu_percent(percpu=True)\navg_cpu_percent = sum(cpu_percent) / len(cpu_percent)",
    "avg_cpu_percent",
    "psutil.cpu_count()",
    "psutil.cpu_count()"
  ],
  "sticky": {}
}